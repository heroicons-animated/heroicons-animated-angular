{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "face-smile",
  "type": "registry:component",
  "title": "face-smile",
  "description": "Animated face-smile icon for Angular",
  "author": "Aniket Pawar <pawaraniket508@gmail.com>",
  "registryDependencies": [],
  "dependencies": [],
  "files": [
    {
      "path": "packages/angular/src/icons/face-smile.ts",
      "type": "registry:component",
      "target": "~/src/app/components/heroicons-animated/face-smile.ts",
      "content": "import {\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  DestroyRef,\n  type ElementRef,\n  effect,\n  inject,\n  input,\n  signal,\n  viewChild,\n} from \"@angular/core\";\n\n@Component({\n  selector: \"hi-face-smile\",\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    \"[attr.aria-label]\": \"'face-smile'\",\n    role: \"img\",\n    \"(mouseenter)\": \"onMouseEnter()\",\n    \"(mouseleave)\": \"onMouseLeave()\",\n  },\n  template: `<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    [attr.width]=\"size()\"\n    [attr.height]=\"size()\"\n    viewBox=\"0 0 24 24\"\n    fill=\"none\"\n    [attr.stroke]=\"color()\"\n    [attr.stroke-width]=\"strokeWidth()\"\n    stroke-linecap=\"round\"\n    stroke-linejoin=\"round\"\n    class=\"icon-svg facesmile-svg\"\n    [class.facesmile-svg-animate]=\"shouldAnimate()\"\n  >\n    <circle cx=\"12\" cy=\"12\" r=\"9\" />\n    <path\n      #mouthPath\n      d=\"M15.182 15.182C13.4246 16.9393 10.5754 16.9393 8.81802 15.182\"\n      pathLength=\"1\"\n      class=\"facesmile-mouth\"\n      [class.facesmile-mouth-animate]=\"shouldAnimate()\"\n    />\n    <path\n      d=\"M9.75 9.75C9.75 10.1642 9.58211 10.5 9.375 10.5C9.16789 10.5 9 10.1642 9 9.75C9 9.33579 9.16789 9 9.375 9C9.58211 9 9.75 9.33579 9.75 9.75Z\"\n      class=\"facesmile-eye\"\n      [class.facesmile-eye-animate]=\"shouldAnimate()\"\n    />\n    <path\n      d=\"M15 9.75C15 10.1642 14.8321 10.5 14.625 10.5C14.4179 10.5 14.25 10.1642 14.25 9.75C14.25 9.33579 14.4179 9 14.625 9C14.8321 9 15 9.33579 15 9.75Z\"\n      class=\"facesmile-eye\"\n      [class.facesmile-eye-animate]=\"shouldAnimate()\"\n    />\n  </svg>`,\n  styles: [\n    `\n      :host {\n        display: inline-block;\n      }\n      .icon-svg {\n        transform-box: fill-box;\n        transform-origin: center;\n      }\n      .facesmile-svg.facesmile-svg-animate {\n        animation: facesmile-svg-bounce 0.8s ease-in-out forwards;\n      }\n      @keyframes facesmile-svg-bounce {\n        0% {\n          transform: scale(1) rotate(0deg);\n        }\n        30% {\n          transform: scale(1.15) rotate(-3deg);\n        }\n        60% {\n          transform: scale(1.05) rotate(3deg);\n        }\n        100% {\n          transform: scale(1.1) rotate(0deg);\n        }\n      }\n      .facesmile-mouth {\n        stroke-dasharray: 1;\n      }\n      .facesmile-mouth.facesmile-mouth-animate {\n        animation: facesmile-mouth-draw 0.5s ease-in-out 0.1s forwards;\n      }\n      @keyframes facesmile-mouth-draw {\n        0% {\n          stroke-dashoffset: 0.7;\n        }\n        50% {\n          stroke-dashoffset: 0;\n        }\n        100% {\n          stroke-dashoffset: 0;\n        }\n      }\n      .facesmile-eye {\n        transform-box: fill-box;\n        transform-origin: center;\n      }\n      .facesmile-eye.facesmile-eye-animate {\n        animation: facesmile-eye-bounce 0.5s ease-in-out forwards;\n      }\n      @keyframes facesmile-eye-bounce {\n        0% {\n          transform: scale(1);\n        }\n        30% {\n          transform: scale(1.5);\n        }\n        60% {\n          transform: scale(0.8);\n        }\n        100% {\n          transform: scale(1.2);\n        }\n      }\n    `,\n  ],\n})\nexport class FaceSmileIcon {\n  readonly color = input(\"currentColor\");\n  readonly size = input(28);\n  readonly strokeWidth = input(1.5);\n  readonly animate = input(false);\n\n  protected isHovered = signal(false);\n  protected shouldAnimate = computed(() => this.animate() || this.isHovered());\n\n  private readonly mouthPathRef =\n    viewChild<ElementRef<SVGPathElement>>(\"mouthPath\");\n  private readonly destroyRef = inject(DestroyRef);\n\n  private readonly MOUTH_PATHS = [\n    \"M15.182 15.182C13.4246 16.9393 10.5754 16.9393 8.81802 15.182\",\n    \"M14.5 14C13 15.5 11 15.5 9.5 14\",\n    \"M15.182 15.182C13.4246 16.9393 10.5754 16.9393 8.81802 15.182\",\n  ] as const;\n  private readonly MOUTH_TIMES = [0, 0.5, 1] as const;\n  private readonly MOUTH_MORPH_DURATION = 400;\n  private readonly MOUTH_MORPH_DELAY = 100;\n  private readonly NUMBER_PATTERN = /-?\\d*\\.?\\d+(?:e[-+]?\\d+)?/gi;\n\n  private readonly parsedMouthPaths: { template: string; numbers: number[] }[];\n  private readonly mouthTemplate: string;\n  private readonly mouthNumberCount: number;\n  private readonly canMorphMouth: boolean;\n  private mouthAnimationFrame: number | null = null;\n  private mouthDelayTimeout: number | null = null;\n\n  constructor() {\n    this.parsedMouthPaths = this.MOUTH_PATHS.map((path) => {\n      const numbers: number[] = [];\n      const template = path.replace(this.NUMBER_PATTERN, (value) => {\n        numbers.push(Number.parseFloat(value));\n        return \"__N__\";\n      });\n      return { template, numbers };\n    });\n    this.mouthTemplate = this.parsedMouthPaths[0].template;\n    this.mouthNumberCount = this.parsedMouthPaths[0].numbers.length;\n    this.canMorphMouth = this.parsedMouthPaths.every(\n      (p) =>\n        p.template === this.mouthTemplate &&\n        p.numbers.length === this.mouthNumberCount\n    );\n\n    effect(() => {\n      if (this.shouldAnimate()) {\n        this.startMouthMorph();\n      } else {\n        this.stopMouthMorph();\n      }\n    });\n    this.destroyRef.onDestroy(() => this.cancelMouthMorph());\n  }\n\n  private formatNumber(value: number): string {\n    return Number(value.toFixed(4)).toString();\n  }\n\n  private interpolatePath(\n    template: string,\n    from: number[],\n    to: number[],\n    progress: number\n  ): string {\n    let numberIndex = 0;\n    return template.replace(/__N__/g, () => {\n      const s = from[numberIndex];\n      const e = to[numberIndex];\n      numberIndex += 1;\n      return this.formatNumber(s + (e - s) * progress);\n    });\n  }\n\n  private cancelMouthMorph() {\n    if (this.mouthDelayTimeout !== null) {\n      clearTimeout(this.mouthDelayTimeout);\n      this.mouthDelayTimeout = null;\n    }\n    if (this.mouthAnimationFrame !== null) {\n      cancelAnimationFrame(this.mouthAnimationFrame);\n      this.mouthAnimationFrame = null;\n    }\n  }\n\n  private setMouthPathAt(progress: number) {\n    const el = this.mouthPathRef()?.nativeElement;\n    if (!el) {\n      return;\n    }\n    if (!this.canMorphMouth) {\n      el.setAttribute(\"d\", this.MOUTH_PATHS[0]);\n      return;\n    }\n\n    const cp = Math.max(0, Math.min(progress, 1));\n    let si = this.MOUTH_TIMES.length - 2;\n    for (let i = 1; i < this.MOUTH_TIMES.length; i++) {\n      if (cp <= this.MOUTH_TIMES[i]) {\n        si = i - 1;\n        break;\n      }\n    }\n    const ss = this.MOUTH_TIMES[si];\n    const se = this.MOUTH_TIMES[si + 1];\n    const lp = se === ss ? 0 : (cp - ss) / (se - ss);\n    el.setAttribute(\n      \"d\",\n      this.interpolatePath(\n        this.mouthTemplate,\n        this.parsedMouthPaths[si].numbers,\n        this.parsedMouthPaths[si + 1].numbers,\n        lp\n      )\n    );\n  }\n\n  private startMouthMorph() {\n    this.cancelMouthMorph();\n    this.mouthDelayTimeout = window.setTimeout(() => {\n      const startTime = performance.now();\n      const step = (time: number) => {\n        const progress = Math.min(\n          (time - startTime) / this.MOUTH_MORPH_DURATION,\n          1\n        );\n        this.setMouthPathAt(progress);\n        if (progress < 1) {\n          this.mouthAnimationFrame = requestAnimationFrame(step);\n        } else {\n          this.mouthAnimationFrame = null;\n        }\n      };\n      this.mouthAnimationFrame = requestAnimationFrame(step);\n      this.mouthDelayTimeout = null;\n    }, this.MOUTH_MORPH_DELAY);\n  }\n\n  private stopMouthMorph() {\n    this.cancelMouthMorph();\n    const el = this.mouthPathRef()?.nativeElement;\n    if (el) {\n      el.setAttribute(\"d\", this.MOUTH_PATHS[0]);\n    }\n  }\n\n  onMouseEnter() {\n    this.isHovered.set(true);\n  }\n  onMouseLeave() {\n    this.isHovered.set(false);\n  }\n}\n"
    }
  ]
}
